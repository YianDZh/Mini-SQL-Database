#include "child_tokens.h"

//! TYPE :
//? token_str 1
//? Result 2
//? relation 7
//? logical 8
//? right 6
//? left 5

TokenStr::TokenStr (): Token (1) {
    _content = "";
}

TokenStr::TokenStr (string something): Token (1){
    _content = something;
}

void TokenStr::print (){
    cout << _content << " ";
}

string TokenStr::get_Value () const{
    return _content;
}
//????????????????????????????????????????????????????????????????
//????????????????????????????????????????????????????????????????
//????????????????????????????????????????????????????????????????

Result_set::Result_set (): Token (2){

}
Result_set::Result_set (vector<long> result): Token (2){
    _result=result;
}
void Result_set::print (){
    cout<<_result<<endl;
}
    // int get_type ();    
vector<long> Result_set::get_Value () const{
    return _result;
}

//????????????????????????????????????????????????????????????????
//????????????????????????????????????????????????????????????????
//????????????????????????????????????????????????????????????????

Relational::Relational (): Token(8){
    _content = "";

}

Relational::Relational (string something):Token (8){
    //!MIGHT NEED A TRY AND CATCH??????
    _content = something;
}

void Relational::print (){
    cout << _content << " ";
}

string Relational::get_Value () const{
    return _content;
}  

Result_set* Relational::eval (const TokenStr field, const TokenStr value, vector<mmap_sl> _ind, map_sl look_up){
    vector <long> res;
    int index = look_up [field.get_Value()];
    string val = value.get_Value();
    if (_content == "="){
        res = _ind [index][val];
    }
    else if(_content == "<"){
        for (mmap_sl::Iterator it = _ind [index].begin(); it != _ind [index].lower_bound (val);++it ){
            for (int i=0; i<(*it).value_list.size();i++){
                res.push_back ((*it).value_list[i]);
            }
        }
    }
    else if (_content == ">"){
        for (mmap_sl::Iterator it = _ind [index].upper_bound(val); it != _ind [index].end ();++it ){
            for (int i=0; i<(*it).value_list.size();i++){
                res.push_back ((*it).value_list[i]);
            }
        }
    }
    else if (_content == ">="){
        for (mmap_sl::Iterator it = _ind [index].lower_bound(val); it != _ind [index].end();++it ){
            for (int i=0; i<(*it).value_list.size();i++){
                res.push_back ((*it).value_list[i]);
            }
        }
    }
    else if (_content == "<="){
    for (mmap_sl::Iterator it = _ind [index].begin(); it != _ind [index].upper_bound (val);++it ){
            for (int i=0; i<(*it).value_list.size();i++){
                res.push_back ((*it).value_list[i]);
            }
        }
    }
    else {
        exit(100);
        //!=
    }
    return new Result_set (res);
}


//????????????????????????????????????????????????????????????????
//????????????????????????????????????????????????????????????????
//????????????????????????????????????????????????????????????????

Logical::Logical ():Token (7){
    _content = "";
}

Logical::Logical (string something):Token (7,something){
    _content = something;
}

void Logical::print (){
    cout << _content << " ";
}

string Logical::get_Value () const{
    return _content;
}

vector <long> Logical::eval (const Result_set a, const Result_set b){
    //and intersection
    //or union
    // cout<<"here\n";
    if (_content == "AND"||_content == "and"){
        vector <long> temp = intersection (a.get_Value(), b.get_Value());
        return (temp);
    }
    else if (_content == "OR" || _content =="or"){
        vector <long> temp = unionVectors (a.get_Value(), b.get_Value());
        return (temp);
    }
    else {
        //! Could do try and catch
        exit (99);
    }

}


//????????????????????????????????????????????????????????????????
//????????????????????????????????????????????????????????????????
//????????????????????????????????????????????????????????????????

 RightParen::RightParen ():Token (6){
    _string = " ";
    _par = ')';
 }
    RightParen::RightParen (string newset):Token(6){
        _string = newset;
        _par = ')';
    }
   void RightParen::print (){
      cout<<_par;
   }


//????????????????????????????????????????????????????????????????
//????????????????????????????????????????????????????????????????
//????????????????????????????????????????????????????????????????

    LeftParen::LeftParen ():Token (5){
        something ="";
        _par = '(';
    }
    LeftParen::LeftParen (string bug):Token (5){
        something=bug;
        _par = '(';
    }
        void LeftParen::print (){
            cout<<_par<<"\t";
        }
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

///? Source : https://www.geeksforgeeks.org/how-to-find-union-of-two-sorted-vectors-in-cpp/https://www.geeksforgeeks.org/how-to-find-union-of-two-sorted-vectors-in-cpp/
vector<long> unionVectors(vector<long> vec1, vector<long> vec2)
{
    vector<long> ans;
    // Declare the set to store the unique elements
    set<long> s;
    // insert elements from vector 1 into the set
    for (long i = 0; i < vec1.size(); i++) {
        s.insert(vec1[i]);
    }
    // insert elements from vector 2 into the set
    for (long i = 0; i < vec2.size(); i++) {
        s.insert(vec2[i]);
    }
    // Store the union of both the vectors into a resultant
    // vector
    for (auto it = s.begin(); it != s.end(); it++) {
        ans.push_back(*it);
    }
    return ans;
}

//? Source: https://stackoverflow.com/questions/19483663/vector-intersection-in-c
vector<long> intersection(vector<long> v1, vector<long> v2){
    vector<long> v3;
    sort(v1.begin(), v1.end());
    sort(v2.begin(), v2.end());

    set_intersection(v1.begin(),v1.end(),v2.begin(),v2.end(),back_inserter(v3));
    return v3;
}


